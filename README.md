
## demo都是在自己搭建的webpack配置中跑的这样便于理解
# 前端常见换肤思路与方案
基本思路还是要回到原生的js和css上来思考这个问题，充分利用css的新特性和css的各种预处理器，再结合现代脚手架更方便的实现。最后进行各种换肤场景的优缺点进行比较分析，采取更合适自己项目的解决应用方案。

## 场景1：深浅两种主题的换肤思路
1. 最直白的方案写两个类名 例如 .dark-name .light-name，然后再项目全局中挂在一个类似themeName的全局变量(此全局变量可以存在浏览器的localstorage或者后端存储)通过切换按钮设置themeName的true或者false来实现
优点：简单直白便于理解 仅仅适用小范围的换肤,不需要使用外部的css预处理器
缺点：扩展性差，大范围换肤不实际 而且很繁琐，仅仅支持两种换肤(非要支持2种以上也可以但是更麻烦)
2. 最直白的方案写两个类名 例如 .dark-name .light-name，然后再项目全局中挂在一个类似themeName的全民变量 通过切换按钮设置themeName的true或者false来实现
优点：简单直白便于理解 仅仅适用小范围的换肤 
缺点：扩展性差，大范围换肤不实际 而且很繁琐，仅仅支持两种换肤(非要支持2种以上也可以但是更麻烦)

## 场景2:多种主题色的换肤
1. 对于自定义组件样式的换肤可以通过CSS Variables实现，对于第三方组件库的换肤可以根据组件库提供的方法实现，如果第三方组件库没有提供灵活的动态换肤可以通过less的modifyVars函数来实现，这个过程可能需要自己配置webpack.concofig.js 或者使用开源的theme webpack之类的插件实现。最重要还是需要理解其中的原理
优点：简单直白便于理解 仅仅适用小范围的换肤,不需要使用外部的css预处理器
 缺点：低版本的第三方组件库换肤配置可能麻烦，最近的版本的第三方组件库很多自带换肤函数用起来很方便



